

#************************** libraries importation **************************#

#standard libraries
import os
import re
import subprocess
import sys
import stat
import getpass
import shutil
import time
from dateutil.parser import parse

#Xroot python api used for eos
from XRootD import client
from XRootD.client.flags import DirListFlags, OpenFlags, MkDirFlags, QueryCode



#Global Variables

#default values if not existing
HARD_CODED_SOFTWARE_PATH_AFS = "/afs/cern.ch/exp/fcc/sw/0.7"
sourcingFCCStack = 'source ' + HARD_CODED_SOFTWARE_PATH_AFS + '/init_fcc_stack.sh'
sourcing_message = "\nPlease ensure that you type the following command every time you want to use FCC softwares : \n" + sourcingFCCStack + '\n'



output_folder = ''
error_folder = ''
log_folder = ''
batch_folder = ''
current_job_id = ''

#batch ouptut directories
cwd = os.getcwd()

#default script working directory
result_folder = cwd + '/FCC_SUBMIT/'

#default log of the script
log_file_name = result_folder + 'fcc_submit_log.txt'


#************************************* Functions Definition ***********************************#



#**************************************#
# Function name : init_fcc_stack       #
# input : none                         #
# role : look for the fcc environnement#
# before running the script            #
#**************************************#

def init_fcc_stack():

    global HARD_CODED_SOFTWARE_PATH_AFS
    global HARD_CODED_HEPPY_PATH_AFS
    global sourcingFCCStack
    global sourcing_message
    global sourcingHEPPY
    global interface


    try:
        SOFTWARE_PATH_AFS=os.environ["FCCSWPATH"]
        sourcingFCCStack = 'source ' + SOFTWARE_PATH_AFS + '/init_fcc_stack.sh'

    except:
        print sourcing_message
        quit()
        


    username = getpass.getuser()
    initial = username[0]

    HARD_CODED_HEPPY_PATH_AFS="/afs/cern.ch/user/"+initial+"/"+username+"/heppy" 


    sourcingHEPPY = 'source ' + HARD_CODED_HEPPY_PATH_AFS + '/init.sh'




#getters and setters


def set_batch(batch):
    global chosen_batch
    chosen_batch = batch

def get_batch():
    global chosen_batch
    return chosen_batch


def set_current_job_id(id):
    global current_job_id
    current_job_id = id

def set_interface(interface_type):
    global interface
    interface = interface_type

def get_interface():
    global interface
    return interface
    
    
def get_last_job_id():
    global current_job_id
    return current_job_id


def get_workspace():

    global output_folder
    global error_folder
    global log_folder
    global batch_folder
    global result_folder

    return result_folder, batch_folder, output_folder, error_folder, log_folder
    

#**************************************#
# Function name : set_workspace        #
# input : folder names                 #
# role : create default folders or     #
# ones provided by user in arguments   #
#**************************************#

def set_workspace(stdout,stderr,log):

    global output_folder
    global error_folder
    global log_folder
    global batch_folder

    global chosen_batch
    global result_folder
    global cwd
    
     

    batch_folder = result_folder + chosen_batch.upper()


    output_folder =  stdout if stdout !="" else batch_folder + '/output'


    error_folder = stderr if stderr !="" else batch_folder + '/error'


    log_folder = log if log !="" else batch_folder + '/log'



    
    #because condor output error like : 'file not writtable'
    
    #stuff may be not necessary
        
    #default permission 
    old_mask = os.umask(0)
    #a second call to change the default permissions (0 similar to chmod 777)
    #like that condor,etc... can write on files ??
    os.umask(0)


    try:

        if not os.path.isdir(output_folder):
            os.makedirs(output_folder)


        if not os.path.isdir(error_folder):    
            os.makedirs(error_folder)

        #no log given by lsf (bhist does not work)
        if not os.path.isdir(log_folder) and chosen_batch == "htcondor":    
            os.makedirs(log_folder)

    except OSError, e:
        raise



#*************************************************#
# Function name : XRootDStatus2Dictionnary        #
# input : xroot status                            #
# role : parse status object generated by         #
# xroot                                           #
#*************************************************#


def XRootDStatus2Dictionnary(XRootDStatus):

    start = '<'
    end = '>'

    XRootDStatus2str = str(XRootDStatus)
    s = XRootDStatus2str


    #print XRootDStatus
    #check the expected line
    try:
        
        status_str = re.search('%s(.*)%s' % (start, end), s).group(1)
        
        #print status_str
    
        status_list = status_str.split(",")

        status_dict = {}

        #print status_list
        
        for infos in status_list:
            info = infos.split(':')
            status_dict[info[0]] = info[1]
 
        #to test
        #status_dict = dict(  (info.split(':')) for info in status_list if '' != info )



        return status_dict    
    except:
        custom_print('Error',"Path error, please enter a valid path",True) 
        



#*************************************************#
# Function name : find_eos_file                   #
# input : filename                                #
# role : check if file exists on eos              #
# before sending the job to the worker            #
#*************************************************#


def find_eos_file(filename):
    #then the file is in eos
    EOS_MGM_URL= 'root://eospublic.cern.ch/'

    eos_file_full_path = EOS_MGM_URL + filename

    with client.File() as eosFile:
        file_status = eosFile.open(eos_file_full_path,OpenFlags.UPDATE)


    #problem with file created directly on eos
    #no problem with dowloded files with (xrdcp)

    #print eos_file_full_path
    #print file_status
    status = XRootDStatus2Dictionnary(file_status)

    if status[' ok'] == ' False':

        return False
    else:
        return eos_file_full_path


#*************************************************#
# Function name : find_file                       #
# input : filename                                #
# role : check if file exists on afs              #
# before checking on eos                          #
#*************************************************#

def find_file(filename):
    
    

    #we suppose that the user enter absolute or relative afs path
    #or only absolute eos path

    if not filename.startswith('/eos/'):
    #afs path are absolute are relative
    #because software are stored in this filesystem
    #and users generally submit their job from afs

        #print "the file is in afs"

        if os.path.isfile(filename):
            return os.path.abspath(filename)
        else:
            return False

    #absolute path
    elif filename.startswith('/eos/'):
        #print "the file is in eos"        
        
        #eos path are absolute
        return find_eos_file(filename)
        
    else:
        return False


#*******************************************************#
# Function name : import_specification                  #
# input : filename                                      #
# role : import the specified file                      #
# a specification file store arguments of the command   #
#*******************************************************#


def import_specification(filename):


        global chosen_batch

        file_content = read_from_file(filename)

        if False != file_content :

            try:
                content = file_content.split('\n')
                imported_specification = dict(  (info.split('=')) for info in content if '' != info )    

            except:
                return [], custom_print('Error',"Invalid specification file !",True)

            #print imported_specification

            chosen_batch = imported_specification['chosen_batch'] if 'chosen_batch' in imported_specification else ''
            fcc_executable = imported_specification['executable'] if 'executable' in imported_specification else ''
            fcc_conf_file = imported_specification['fcc_conf_file'] if 'fcc_conf_file' in imported_specification else ''
            fcc_output_file = imported_specification['fcc_output_file'] if 'fcc_output_file' in imported_specification else ''
            NOR = imported_specification['number_of_runs'] if 'number_of_runs' in imported_specification else ''
            NOE = imported_specification['number_of_events'] if 'number_of_events' in imported_specification else ''
            temp_fcc_input_files = imported_specification['fcc_input_files'] if 'fcc_input_files' in imported_specification else ''
            fcc_input_files = temp_fcc_input_files.split(' ') if temp_fcc_input_files != '' else ''


            batch_original_arguments = imported_specification['batch_original_arguments'] if 'batch_original_arguments' in imported_specification else ''
            stdout = imported_specification['stdout'] if 'stdout' in imported_specification else ''
            stderr = imported_specification['stderr'] if 'stderr' in imported_specification else ''
            log = imported_specification['log'] if 'log' in imported_specification else ''

            return [chosen_batch, fcc_executable, fcc_conf_file ,fcc_output_file, NOR , NOE , fcc_input_files ,batch_original_arguments, stdout, stderr, log] , True

        else:
            return [] , False


#*******************************************************#
# Function name : save_specification                    #
# input : filename                                      #
# role : save spec in the specified file                #
# a specification file store arguments of the command   #
#*******************************************************#

def save_specification(specification_values,filename):

    specification_keys = ['chosen_batch', 'executable', 'fcc_conf_file', 'fcc_output_file', 'number_of_runs', 'number_of_events', 'fcc_input_files', 'batch_original_arguments', 'stdout', 'stderr', 'log']

    specification_list = []

    for key,value in zip(specification_keys,specification_values):
        specification_list+= [key + '=' + value]

    specification_text = '\n'.join(specification_list) + '\n'

    write2file('w',filename,specification_text)
    

#***********************************#
# Function name : write2file        #
# input : filename and its content  #
# role : write the content in a file#
#***********************************#

def write2file(operation,filename,filetext):

    try:

        #create file with w permission
        with open(filename,operation) as text_file:
            text_file.write(filetext)
    except:
         custom_print('Error','Error in writting file',False)    
    
    
#********************************************#
# Function name : read_from_file             #
# input : filename                           #
# role : read a file and return its content  #
#********************************************#

    
def read_from_file(filename):

    try:
        #create file with w permission
        with open(filename) as f:
            content = f.read()
        return content
    except:
        return False


#********************************************#
# Function name : custom_print               #
# input : message and options                #
# role : print message to gui or shell       #
# if shell, quit in case of error            #
# but in gui do not quit,                    #
# we can 'replay' action, hence the replay   #
# variable                                   #
#********************************************#

def custom_print(message_type,message,exit):
    
    global interface

    if interface == 'cli':
        print message
        if True == exit:
            quit()
    else:
        #if interface is gui, it means that gui has perfectly been loaded so no need to make 'try' import
        #import directly
        import fcc_submit_gui as gui
        gui.display_error_message(message_type,message)
        return False


#********************************************#
# Function name : get_answer                 #
# input : question                           #
# role : query the user on shell or gui      #
# and catch the answer                       #
#********************************************#

def get_answer(question,answer_type):

    global interface    
    
    if interface == 'cli':
        return raw_input(question).lower()
    else:
        #if interface is gui, it means that gui has perfectly been loaded so no need to make 'try' import
        #import directly
        import fcc_submit_gui as gui
        return gui.display_question(question,answer_type)


#**********************************************************#
# Function name : install_software                         #
# input : software                                         #
# role : install software (from github) not present        #
# in afs to the user home directory                        #
# ie. heppy                                                #
#**********************************************************#

def install_software(executable_name):
    
    global interface    
    global HARD_CODED_HEPPY_PATH_AFS

    replay = True

    yes = set(['yes','y', 'ye', ''])
    no = set(['no','n'])


    heppy_path = HARD_CODED_HEPPY_PATH_AFS

    answer = get_answer('\nYou plan to use '"heppy"', as it not installed on afs, it must be installed on your user directory :\nIs heppy already installed ? (y/n)\n','short')
            


    if answer in yes:


        answer = get_answer('\nThe script will take this location as the default heppy folder :\n' + heppy_path + ' \nEnter yes if you want to continue else no if you want to specify another heppy path) (y/n)\n','short')
    
        if answer in no:

            heppy_path = get_answer('Enter the full path of your heppy folder:','long')

            #make sure that the provided folder is a heppy folder and not whatever
            if not os.path.isdir(heppy_path) or not os.path.isfile(heppy_path + '/bin/' + executable_name) :

                message = '\nThe path "'+ heppy_path +'" is not valid\nInstallation aborted\n'
                replay = custom_print('Error',message,True)

        

        elif answer in yes:
            if not os.path.isdir(heppy_path):
                message = '\nHeppy is not installed\nInstallation aborted'
                replay = custom_print('Error',message,True)
        else :
            message = '\nbad answer\nInstallation aborted'
            replay = custom_print('Error',message,True)

    elif answer in  no:
        answer = get_answer('Do you want an automatic installation ? (y/n)','short')


        
        if answer in yes:

    
                    

            try:                         
                from git import Repo     
            except:                         
                #the problem is that when we source the bash script init_fcc_stack.sh                         
                #it modifies the python path and GIT module can no longer be imported                         
                #so try to re-add the path to python path
                    
                GIT_MODULE_LOCATION = '/usr/lib/python2.6/site-packages/'                          
                GITDB_MODULE_LOCATION = '/usr/lib64/python2.6/site-packages/'

                sys.path.append(GIT_MODULE_LOCATION)
                sys.path.append(GITDB_MODULE_LOCATION)                              
            
                try:                             
                    from git import Repo                         

                except ImportError:
                    message = '\nMissing git libraries\nPlease try manual installation\n'                            
                    replay = custom_print('Error',message,True)                      

            try:

                if os.path.isdir(heppy_path):
                    answer = get_answer('\nHeppy is already installed on this location :\n'+heppy_path+'\nRemove it and process to a new installation ? (y/n)\n','short')
            
                    if answer in yes:
                        #remove folder and clone from github
                        shutil.rmtree(heppy_path)

                        print 'Installation in progress...' 
                        Repo.clone_from('https://github.com/HEP-FCC/heppy', heppy_path)

                    elif answer in no:
                        message = '\nInstallation canceled'
                        replay = custom_print('Error',message,True)
                    else:
                        message = '\nbad answer\nInstallation aborted'
                        replay = custom_print('Error',message,True)

                else:
                    print 'Installation in progress...' 
                    Repo.clone_from('https://github.com/HEP-FCC/heppy', heppy_path)
        
            except:
                message = '\nCloning from the https://github.com/HEP-FCC/heppy git repository produces an error\nHeppy seems to be already installed\nInstallation aborted\n'
                replay = custom_print('Error',message,True)
                    
        elif answer in no:
            #if manual instalation but heppy installed , continue and do not quit
           
            message = """\nPlease follow the instructions in this tutorial :
https://github.com/HEP-FCC/heppy
Install the repository on your home directory ~:
Re-run the script and choose yes when "Is Heppy already installed" is asked
After this script will automatically source the file : ~/heppy/init.sh\n"""

            replay = custom_print('Information',message,True)
    
        else:
            message = '\nbad answer\nInstallation aborted\n'
            replay = custom_print('Error',message,True)
    
        

    else:
        message = '\nbad answer\nInstallation aborted\n'
        replay = custom_print('Error',message,True)
    

    if True == replay:

        #generation of the heppy init.sh script

        heppy_init_file_text = []
        heppy_init_file_text += ['export HEPPY='+heppy_path]
        heppy_init_file_text += ['export PATH=$HEPPY/bin:$PATH'] 
        heppy_init_file_text += ['export PYTHONPATH=$HEPPY/..:$PYTHONPATH'] 
        heppy_init_file_text += ['cp $HEPPY/scripts/*.py $HEPPY/bin/'] 
        heppy_init_file_text += ['chmod +x $HEPPY/bin/*.py'] 


        #overwrite init.sh script on heppy folder

        write2file('w',heppy_path + '/init.sh','\n'.join(heppy_init_file_text))

        sourcingHEPPY = 'source ' + heppy_path + '/init.sh'

        #sourcing of the script
        subprocess.call(sourcingHEPPY,shell=True)

    return replay

#*************************************************#
# Function name : search_executable               #
# input : executable                              #
# role : check heppy else print sourcing message  #
#*************************************************#

def search_executable(executable):

    global interface    
    

    replay =  True     

    replay = custom_print('Information',"Your executable " + executable + " must be a 'pre-existing' software",False)

    if executable != 'heppy_loop.py':
    

        message = "\nThe file '" + executable + "' does not exist\nPlease upload your file in an accessible file system (EOS or AFS)\n"

        if interface == 'cli':
            message += sourcing_message            
        
        replay = custom_print('Error',message,True)
    
    else:    

        replay = install_software(executable)

    return replay

#*************************************************#
# Function name : generate_bash_script            #
# input : bash commands and script name           #
# role : generate bash script                     #
#*************************************************#


def generate_bash_script(commands,script_name):

    global sourcingFCCStack
    global sourcingHEPPY


    shebang = "#!/bin/bash"
    bash_script_text = [shebang, sourcingFCCStack, sourcingHEPPY] + commands    


    #write the temporary job
    write2file('w',script_name,'\n'.join(bash_script_text) + '\n')    

    #make the job executable and readable for all
    chmod(script_name,'R')    
    chmod(script_name,'X')



#****************************************************#
# Function name :  get_job_id                        #
# input : output                                     #
# role : search id in the standard ouput of batch    #
#****************************************************#

def get_job_id(batch_output):

    
    global chosen_batch

    start = '<'
    end = '>'
    
    s = batch_output

    if chosen_batch == 'lsf':
        job_id_str = re.search('%s(\d+)%s' % (start, end), s)
    else:    
        job_id_str = re.search('cluster (\d+\.\d*)',s)


    #check the expected line
    try:
        job_id = job_id_str.group(1)
        
        if job_id.endswith('.') : job_id = job_id + '0'


    except:
        custom_print('Error',"\nYour job has probably not been submitted\n"+ chosen_batch.upper() + " outputs an error, please check your configuration\n",False)     
        job_id = "unkown_id"

    set_current_job_id(job_id)
    return job_id

#****************************************************#
# Function name :  is_executable_exist               #
# input : executable                                 #
# role : search executable in the environnement      #
#****************************************************#

def is_executable_exist(executable_name):

    #we have a space here (see after how to manage)
    #./run gaudirun.py
   
    if not ' ' in executable_name:

        for path in os.environ["PATH"].split(os.pathsep):
        #print path
            for root, dirs, files in os.walk(path):
                if executable_name in files:
                #print files
                    return True
            return False 
            
    #ie.  ./run gaudirun.py           
    else:

        dot_slash = './'
        temp_executable_name = executable_name.split()
    

    #the first may be the executable
    filename = temp_executable_name[0]

    if dot_slash in filename:
        filename = filename.replace(dot_slash,'')
    
    searched_file = find_file(filename)
    

    return searched_file != False

#****************************************************#
# Function name :  chmod                             #
# input : permission                                 #
# role : change permission                           #
# function created when condor outputs error like :  #
# 'files not writtable by condor'                    #
#****************************************************#

def chmod(file,permission):

    #reflet chmod a+permission 
    #make the file executable for everyone
    USER_PERMISSION = eval('stat.S_I'+permission+'USR')
    GROUP_PERMISSION = eval('stat.S_I'+permission+'GRP')
    OTHER_PERMISSION = eval('stat.S_I'+permission+'OTH')

    PERMISSION = USER_PERMISSION | GROUP_PERMISSION | OTHER_PERMISSION

    #get actual mode of the file
    mode = os.stat(file).st_mode

    os.chmod(file,mode | PERMISSION)


#****************************************************#
# Function name :  save_history                      #
# input : job id, batch used ...                     #
# role : log each submissions                        #
#****************************************************#

def save_history(job_id, batch, executable, submitted_time):


    global log_file_name

    log = []

    if not os.path.isfile(log_file_name):
        HEADER = 'JOB ID\t\t\tBATCH\t\t\tSUMITTED TIME\t\t\tExecutable'    
        log += [HEADER]


    info = [job_id, batch, submitted_time, executable]



    log += ['\t\t'.join(info)]

    write2file('a',log_file_name, '\n'.join(log) + '\n')


#*******************************************************#
# Function name :  display_history                      #
# input : intervalle                                    #
# role : display history of submissions to the user     #
#*******************************************************#

def display_history(intervalle):


    global log_file_name

    default_min = 0
    dates = False
    times = False
    full = False
    time_and_date = False
    date_and_time = False

    values = intervalle


    if len(values) == 4:
        user_start_date = values[0]
        user_start_time = values[1]

        user_end_date = values[2]
        user_end_time = values[3]

        dates = True
        times = True
        full = True

        if not (is_date(user_start_date) and  is_time(user_start_time) and is_date(user_end_date) and is_time(user_end_time)):
            custom_print('Error','Invalid values',True)
    
    elif len(values) == 2:
        user_min = values[0]
        user_max = values[1]

        if is_date(user_min) and is_date(user_max):
            dates = True
        elif is_time(user_min) and is_time(user_max):            
            times = True
        elif is_date(user_min) and is_time(user_max):
            date_and_time = True
            times = True
            dates = True
        elif is_time(user_min) and is_date(user_max):
            time_and_date = True            
            times = True
            dates = True
        elif not is_int(user_min) or not is_int(user_max):
            custom_print('Error','Invalid values',True)

    elif len(values)== 1:

        user_min = values[0]

        if is_date(user_min):
            dates = True
        elif is_time(user_min):
            times = True
        elif not is_int(user_min):
            custom_print('Error','Invalid values',True)

    elif len(values)== 0:
        user_min = 'min'
        user_max = 'max'

    else:
        custom_print('Error','Invalid values',True)
    

    

    if os.path.isfile(log_file_name):
        file_content = read_from_file(log_file_name)
        file_content_listed = file_content.split('\n')

        histories = file_content_listed[1:]

        default_max = len(histories) - 1

        


        if not dates and not times:

            if 'min' == user_min and 'max' == user_max:
                user_min = default_min
                temp_user_max = default_max
            else:

                if 'user_max' not in locals():
                    temp_user_max = default_max
                else:
                    temp_user_max = int(user_max)

                if 'user_max' not in locals():
                    user_min= temp_user_max - int(user_min)
                else:
                    user_min= int(user_min) - 1


            end = temp_user_max if (temp_user_max <= default_max and temp_user_max >= default_min) else default_max
            start = user_min if (user_min <= end and user_min >= default_min) else default_min
    
            

        else:
        
            mytimes = []
            mydates = []
            
            old_date = None
            old_time = None


            for history in histories :
                
    
                try:
                    if '' != history:
                        mydates += [re.search('\d+/\d+/\d+',history).group(0)]
                        mytimes += [re.search('\d+:\d+:\d+',history).group(0)]

                except:                    
                    custom_print('Error','Invalid values',True)


            if date_and_time or time_and_date:

                try:    
                    formated_user_date = time.strptime(user_min, "%m/%d/%y") if (date_and_time or time_and_date) else time.strptime(user_max, "%m/%d/%y")

                except:                    
                    custom_print('Error','Invalid values',True)

                user_time = user_max if date_and_time else user_min


                for index,(mydate, mytime) in enumerate(zip(mydates,mytimes)):

                    try:
                        formated_history_date = time.strptime(mydate, "%m/%d/%y")
                    except:                    
                        custom_print('Error','Invalid values',True)            
                    
                #    print formated_user_date >= formated_history_date 
                    #print user_time >= mytime
                    #print old_time , old_date

                    if formated_user_date >= formated_history_date and user_time >= mytime :
                        start = index + 1
                        print index
            

                end = default_max


            elif full:

                start = None
                
                try:
                    formated_user_start_date = time.strptime(user_start_date, "%m/%d/%y")
                    formated_user_end_date = time.strptime(user_end_date, "%m/%d/%y")
                
                except:                    
                    custom_print('Error','Invalid values',True)

                for index,(mydate, mytime) in enumerate(zip(mydates,mytimes)):


                    try:
                        formated_history_date = time.strptime(mydate, "%m/%d/%y")
                    except:                    
                        custom_print('Error','Invalid values',True) 

               
                    
                    if formated_user_start_date <= formated_history_date and user_start_time <= mytime and mytime != old_time and formated_history_date != old_date:
                        start = index   
                    if formated_history_date < formated_user_start_date:
                        end = index + 1
                    elif formated_history_date == formated_user_end_date and user_end_time >= mytime:       
                        end = index + 1
                        
                    old_time = mytime
                    old_date = formated_history_date
                    

            else:
                if dates:
                    


                    try:
                        formated_user_start_date = time.strptime(user_min, "%m/%d/%y")
                    except:                    
                        custom_print('Error','Invalid values',True)                    
            

                    for index,mydate in enumerate(mydates):

                        try:
                            formated_history_date = time.strptime(mydate, "%m/%d/%y")
                        except:                    
                            custom_print('Error','Invalid values',True)

                        if  formated_user_start_date >= formated_history_date and formated_history_date != old_date:
                            #for min take the first else for max take the last
                            start = index
                        if 'user_max' in locals():
                            print 'true'
                            
                            formated_user_end_date = time.strptime(user_max, "%m/%d/%y")
                            if formated_user_end_date >= formated_history_date:
                                end = index + 1
                        else:
                            end = default_max

                        old_date = formated_history_date

                            
                elif times:



                    for index,mytime in enumerate(mytimes):

                        
                        
                        if user_min >= mytime and mytime != old_time:
                            start = index + 1
                        

                        if 'user_max' in locals():
                            if user_max >= mytime:    
                                end = index + 1
                        else:
                            end = default_max
                    
                        old_time = mytime

        print file_content_listed[0] + '\n' + '\n'.join(histories[start:end])        



    else:
        custom_print('Error','History not available',True)


#data type checking

def is_int(input):
    try: 
        int(input)
        return True
    except ValueError:
        return False



def is_date(input):
    
    try:
        time.strptime(input, '%m/%d/%y')
        return True
    except ValueError:
        return False

def is_time(input):

    try:
        time.strptime(input, '%H:%M:%S')
        return True
    except ValueError:
        return False
    
